[有道笔记有配图](http://note.youdao.com/noteshare?id=77a1706fa06f9c89bef8adc23187ec85&sub=30DDE45EF96E4DB4AB2B5441FCDE8E4F)
## 为什么学习函数式编程？
函数式编程是一个非常古老的概念，它的出现甚至早于第一台计算机的诞生，函数式编程的历史可以通过《函数式编程的历史》这篇文章了解一下
### 为什么学习函数式编程？
- 函数式编程treact的流行受到了越来越多的关注react的高阶组件使用了高阶函数来实现，高阶函数就是函数式编程的一个特性
- vue3vue2做了很大的重构，更偏向于函数式编程
- 函数式编程可以抛this
- 使用函数式编程可以更好的利treesshacking来过滤无用的代码
- 使用函数式编程还可以方便测试，方便并行处理等
- 还有很多路可以帮助我们进行函数式编程的开发比lodash

## 函数式编程的概念
### 什么是函数式编程？
- 函数式编程英文名functioalPprogramme，简FP
- 函数式编程是一种编程的范式，可以认为是一种编程的风格，和面向对象是一种并列的关系
- 函数式编程我们可以认为是一种思维的模式加上它的实现方法，我们长听说的编程方式和面向过程编程和面向对象编程，面向过程编程，简单解释就是按照步骤来实现，一步一步来实现我们想要的功能，面向对象编程是把现实中的事物抽象成程序中的类和对象，然后通过封装、继承和多肽来演示事物之间的联系。
- 函数式编程的方式是把现实中的事物与事物之间的联系抽象到程序世界中
  - 程序的本质是根据输入会得到相应的输出，程序开发过程中会涉及到很多输入输出的函数，函数式编程就是对这些运算过程抽象
  - 函数式编程中的函数指的不是程序中的函数或者方法，函数式编程中的函数指的是数学中的函数,即映射关系,例如y=sin(x)中的x与y的关系
  - 相同的输入始终得到相同的输出
  - 函数式编程用来描述数据(函数)之间的映射
  
```
//非函数式
let num1 = 2
let num2 = 3
let sum = num 1 + num2
console.log(sum)
//函数式
function  add(n1 , n2){
    return n1 + n2
}
let sum = add(1,2)
console.log(sum)
```
## 函数是一等公民
- 函数可以存储在变量中
- 函数可以作为参数
- 函数可以作为返回值

在JavaScript中函数是一个普通的对象(可以通过new function()),我们可以吧函数存储到变量/数组中,它还可以作为另一个函数的参数和返回值,甚至我们可以在程序运行的时候通过new function('alert(1)')来构造一个新的函数
### 把函数赋值给变量
```
let fn = function(){
    console.log('hhh')
}
fn()
//示例
const obj = {
    a(p){return vs.a(p)},
    b(p){return vs.b(p)},
    c(p){return vs.c(p)},
}
//优化
const obj = {
    a: vs.a(p),
    b: vs.b(p),
    c:vs.c(p),
}
```
### 函数是一等公民是我们学习高级函数、柯里化等的基础

## 高级函数--函数作为参数
### 什么是高级函数？
- 高阶函数可以把函数作为参数传递给另外一个函数

- 可以把函数作为另外一个函数的返回结果

```
// 高阶函数-函数作为参数

// 封装一个forEach函数,遍历每一个数组中的元素
function forEach(array,fn){
    for(let i = 0 ; i < array.length ; i++){
        fn(array[i])
    }
}
//测试一下这个函数
let arr = [1,3,5,7,9]
forEach(arr,function(item){
    console.log(item)
})
// 封装一个fliter函数，过滤一个满足条件的数组

function filter (array,fn){
    
    let result = []
    for(let i = 0 ; i < array.length ; i++){
        // 在fn中指定满足的条件,处理每个对象
        // 如果满足条件
        if(fn(array[i])){
            result.push(array[i])
        }
    }
    return result;
}
// 测试
let arr2 = [1,2,4,7,8]
let r = filter(arr2,function(item){
    return item%2 === 0
})
console.log(r)//[ 2, 4, 8 ]
```
### 函数作为参数的好处？
- 函数作为参数可以让我们的参数变得更灵活，
- 而且我们在调用它的时候不需要考虑它是怎么实现的，
- 这个函数把内部实现的细节帮我们屏蔽了，
- 而且函数的名字是有实际意义的，
- 比如forEach这个名字就知道是遍历数据，filter是过滤数据
## 高级函数--函数作为返回值

```
// 高阶函数-函数作为返回值
// 想象一下，如果函数作为返回值的话，就是一个函数去生成另一个函数
// 下面是基本语法演示
function makeFn(){
    let msg = 'hello function'
    return function (){
        console.log(msg)
    }
}
// 调用方法1
const mf = makeFn();
mf();//hello function
// 调用方式2
makeFn()();//hello function
// ---------------------------
/**lodash中的once函数--对于一个函数只执行一次，
 * 可以用于用户支付的时候，
 * 不管用户点多少次按钮只支付一次订单
*/
function once (fn){
    // 如何只执行一次呢？
    // 1.定义一个变量，这个变量是一个标记
    let done = false;//默认fn函数没有执行
    return function(){//返回一个函数
        if(!done){//2.先判断一下这个函数是否已经被执行过
            // 如果判断fn函数没有执行过,
            // 我们先把fn设置为执行过
            done = true
            // this指向当前的函数的 this
            // arguments获取当前函数的参数
            const _this = this;
            console.log(_this,arguments)
            
            return fn.apply(this,arguments)
        }
    }
}
// 通过once函数生成一个只能够执行一次的函数
let pay = once(function(money){
    console.log(`支付：${money} RMB`)
    
})
pay(5)
pay(6)
pay(7)
pay(8)
```
## 高级函数的意义
- 抽象可以帮助我们屏蔽细节，只需要关注与我们的目标
- 高阶函数用来抽象通用问题

```
//面向对象的方式
let array = [1，2，3，4]
for(let i = 0 ; i < array.length ; i++){
    console.log(array[i])
}
//高阶函数
let array = [1，2，3，4]
forEach(array,item=>{
console.log(item)
    
})
let r = filter(array,item=>{
    return item % 2 === 0
})
```
## 常用的高阶函数
- forEach
- map
- filter
- every
- some
- find/findIndex
- reduce
- sort
- .....

```
// 模拟常用高阶函数:map  every some
// map--数组中的方法,对数组中的每一个成员遍历,并对每一个元素进行处理,然后把处理的结果存储到一个新的结果中返回

// 函数表达式的方式
const map = (array,fn) => {
    let results = []
    for(let value of array){
        results.push(fn(value))
    }
    return results
}
// 测试
let arr = [1,2,3,4]
// 求每个数组值的平方的函数
arr = map(arr,v => v*v);
console.log(arr);//[ 1, 4, 9, 16 ]
/**
 * map函数的好处是我们可以使用第二个参数来对数组中的每一个成员做任意处理,所以函数作为参数会让map参数更灵活
*/
//-------------------------------------
//every --判断数组中的每一个元素是否都匹配指定的条件
const every = (array,fn) =>{
    // console.log(array,fn)
    let result = true
    for(let value of array){
        result = fn(value)
        if(!result){
            break;
        }
    }
    return result;
}
// 测试
let arr2 = [12,11,55]
let r2 = every(arr2,v =>v > 10);
console.log(r2)
/**
 * every函数有一个参数时函数的时候也可以让我们的函数变得非常灵活,可以检测数组中的元素是否满足任意的条件
 */
//------------------------------------
// some--检测数组中的元素是否有一个满足指定的条件
const some = (array,fn) =>{
    // console.log(array,fn)
    let result = true
    for(let value of array){
        result = fn(value)
        if(result){
            break;
        }
    }
    return result;
}
// 测试
// 检测数组中是否有偶数
let arr3 = [1,2,3,9]
let r3 = some(arr3,v => v%2 === 0)
console.log(r3)
// 高阶函数:通过把一个函数传递给另一个函数可以让这个函数更灵活
```

## 闭包
### 闭包的概念:
- 函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包.
- 可以在另一个作用域中调用一个函数的内部函数并访问到该函数作用域中的成员

```
//函数作为返回值
function makeFn(){
    let msg = 'hello function'
    return function (){
        console.log(msg)
    }
}
const fn = makeFn()
fn()
```

```
//once
function once (fn){
    let done = false;
    return function(){
        if(!done){
            done = true
            return fn.apply(this,arguments)
        }
    }
}
let pay = once(function(money){
    console.log(`支付:${money}RMB`)
})
pay(5)
pay(5)
```

### 闭包的本质
函数在执行的时候回放在一个执行栈上,当函数执行完毕后会从执行栈上移除,但是堆上的作用域成员因为被外部引用不能释放,因此内部函数依然可以反问外部函数的成员.
## 闭包--案例
案例1

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>closure</title>
    <script>
        // Math.pow(2,2)
        // Math.pow(3,2)
        // 封装幂函数
        function makePower(power){
            return function(number){
                return Math.pow(number,power)
            }
        }
        let power2 = makePower(2);//求2次幂
        let power3 = makePower(3);//求3次幂
        console.log(power2(4))
        console.log(power2(5))
        console.log(power3(4))
    </script>
</head>
<body>
    
</body>
</html>
```
案例2

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>closure</title>
    <script>
        // 求取不同级别员工的工资= 绩效工资+ 基础工资
        function makeSalary(base){
            return function(performance){
                return base + performance
            }
        }
        let sl1  = makeSalary(12000);//级别1的基本工资
        let sl2 = makeSalary(15000);//级别2的基本工资
        console.log(sl1(3000));//级别1的绩效工资
        console.log(sl2(3000));//级别2的绩效工资
        // 在浏览器的sources打断点调试,看Call Stack(调用栈)和Scope(作用域),观察Scope查看闭包是什么时候发生的
    </script>
</head>
<body>
    
</body>
</html>
```
## 纯函数
### 纯函数的概念
- 纯函数:相同的输入永远会得到相同的输出,而且没有任何可观察的副作用
    - 纯函数类似数学中的函数(用来描述输入和输出之间的关系),y=f(x)
- lodash是一个纯函数的功能库,提供了对数组、数字、对象、字符串、函数等的操作的一些方法
- 数组的slice和splice分别是纯函数和不纯的函数
    - slice返回的是数组中指定部分，不会改变原来的数组
    - splice 对数组进行操作返回该数组，会改变原数组

```
// 纯函数和不纯的函数
//案例 slice / splice
let arr = [1,2,3,4,5]
// 纯函数:相同的输入有相同的输出
console.log(arr.slice(0,3))
console.log(arr.slice(0,3))
console.log(arr.slice(0,3))

// 不纯的函数:相同的输入有不同的输出
console.log(arr.splice(0,3))
console.log(arr.splice(0,3))
console.log(arr.splice(0,3))

// -------------------------
// 自己写一个纯函数
function getSum (n1 , n2){
    return n1 + n2
}

console.log(getSum(1,3))
console.log(getSum(1,3))
console.log(getSum(1,3))
// 函数式编程不会保留计算中间的结果,所以变量是不可变得(无状态的)
//当我们在调用这个函数的时候,我们吧一个函数的执行结果交给另一个函数去处理
```

## lodash（纯函数的代表）
Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。

```
// 演示lodash的几个常用方法
// first / last / toUpper / reverse / each / includes / find / findIndex
// 配置package.json文件 npm init -yes
// 安装lodash npm i lodash
const _ = require('lodash');

let arr = ['yrn','hcb','pjg','slg'];

console.log(_.first(arr));//@return — Returns the first element of array.获取第一个
console.log(_.last(arr))//@return — Returns the last element of array.获取最后一个
console.log(_.toUpper(arr[0]))//@return — Returns the upper cased string.全部大写
console.log(_.reverse(arr));//翻转数组
// 遍历简写
_.each(arr,(item,index)=>{
    console.log(item,index)
})
// includes:判断在当前集合中是否存在这个值,索引默认从0开始,如果是负数就从末尾开始检索
console.log(_.includes(arr,'hcb',0))
//find 在集合中查找到第一个匹配的元素并返回,第二个参数可以是Array|Function|Object|string

const users = [
    { 'user': 'barney',  'age': 36, 'active': true },
    { 'user': 'fred',    'age': 40, 'active': false },
    { 'user': 'pebbles', 'age': 1,  'active': true }
  ];
console.log(_.find(users,['active',false]));//{ user: 'fred', age: 40, active: false }
console.log(_.find(users,o => o.age < 36))
console.log(_.find(users,'active'))
// findIndex类似find区别是返回的是第一个查找到的元素的索引,而不是元素本身
console.log(_.findIndex(users,'active'))

```
## 纯函数的优势

1. 可缓存----提高程序的性能
    - 因为相同的输入始终会有相同的输入，所以可以把纯函数的结果缓存起来
    - 场景：当函数需要多次调用的时候我们可以缓存起来用来提高性能


```

//记忆函数 memoise函数
const _ = require('lodash');
// 计算圆的面积
function getArea(r){
    console.log(r)
    return Math.PI * r * r
}
// 调用memoise使getArea方法的返回值有缓存
// let getAreaWithMemory = _.memoize(getArea);
// console.log(getAreaWithMemory(4))
// console.log(getAreaWithMemory(4))
// console.log(getAreaWithMemory(4))
// console.log(getAreaWithMemory(4))
/**4
 * 50.26548245743669
 * 50.26548245743669
 * 50.26548245743669
 * 50.26548245743669
 * 从输出结果我们可以看到getArea函数只调用了一次
*/
//-------------------------------------
// memoise函数的内部实现过程
function memoize(f){
    let cache = {}
    return function(){
        let key = JSON.stringify(arguments)
        // 先判断返回中是否有值,如果有值直接返回,如果没有值就返回f函数
        cache[key] = cache[key]|| f.apply(f,arguments)
        return cache[key]
    }
}
let getAreaWithMemory = memoize(getArea);
console.log(getAreaWithMemory(4))
console.log(getAreaWithMemory(4))
console.log(getAreaWithMemory(4))
console.log(getAreaWithMemory(4))
// 测试的结果和刚才的一样,说明我们模拟的结果是ok的
```

2. 可测试
3. 并行处理
   - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
   - 纯函数不需要范文共享的内存数据,所以在并行环境下可以任意运行纯函数,如JavaScript现在多出了Web Worker线程

## 函数的副作用
副作用会让一个函数变得比纯，纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证相同的输出，就会带来副作用
### 副作用的来源
- 配置文件
- 数据库
- 获取用户的输入
- 。。。。。。。。。。
> 所有的外部交互都有可能带来副作用，副作用也使得方法的通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患，给程序带来不确定性，但是不作用不可能完全禁止，尽可能控制它们在可控范围内发生

## 柯里化（curry）

```
// 柯里化演示

// function checkAge(age){
//     let min = 18
//     return age >= min
// }
//--------------------------
// 进一步改进---普通的纯函数
// function checkAge (min,age){
//     return age >= min
// }
// console.log(checkAge(18,20))
// console.log(checkAge(18,24))
// console.log(checkAge(19,22))
//-----------------------------
// 当最小值一直都是18的时候上面这种调用方法就不合适了
// 更进一步改进----闭包/高级函数
// function checkAge(min){
//     return function(age){
//         return age >= min
//     }
// }
// es6写法
let checkAge = min => (age => age >= min);
let checkAge18 = checkAge(18);//最小年龄18
let checkAge20 = checkAge(20);//最小年龄20

console.log(checkAge18(20))
console.log(checkAge20(24))
/**
 * 以上这种形式就是函数的柯里化
 * 当我们的函数有多个参数的时候,我们可以对这个函数进行改造
 * 我们可以调用一个函数只传递部分的参数,
 * 并且让这个函数返回新的函数,
 * 让这个新的函数去接收剩余的参数并且返回相应的结果,
 * 这就是函数的柯里化
 * */ 
/**
 * 总结:
 * 柯里化(currying)
 *      1.当一函数有多个参数的时候先传递一部分参数调用它(这部分参数以后永远不变)
 *      2.然后返回一个新的函数接收剩余的参数,返回结果
 */
```
## lodash中的柯里化函数
- _.curry(func)
  - 功能：创建一个函数，该函数接收一个或多个func的函数，如果func所需要的参数都被提供则执行func并返回执行的结果，否则继续返回该函数并等待接收剩余的参数。
  - 参数：需要柯里化的函数
  - 返回值：柯里化后的函数
  
```
// lodash中的curry基本使用
const _ = require('lodash')
//有三个参数叫三元函数,有几个参数就叫几元函数
function getSum(a,b,c){
    return a + b + c;
}
// 柯里化可以把多元函数最终转化为一个一元函数
const curried = _.curry(getSum)
console.log(curried(1,2,3));//仅仅是包装没意义
// 如果我们传递getSum的部分参数,
// curry会返回一个新的函数用来接收剩余参数
console.log(curried(1)(2,3))//此时结果是一样的
// lodash的curry函数是吧多元函数编程一元函数
console.log(curried(1,2)(3))



```
## 柯里化案例

```
// 柯里化案例
// 假设我们判断字符串中是否有空白字符或提取字符串中的空白字符可以使用字符串的match方法
// 面向对象方法
// ''.match(/\s+/g);//匹配提取字符串中的所有空白字符
// ''.match(/\d+/g);//匹配提取字符串中的所有数字
// 那如何提取数组中的元素的空白字符或数字呢?
// 使用函数式的方法匹配提取字符串中的内容
// match纯函数
// function match(reg,str){
//     return str.match(reg)
// }
const _ = require('lodash')

// 进行柯里化处理
const match = _.curry(function(reg,str){
    return str.match(reg)
})
// 判断是否有空白字符
const haveSpace = match(/\s+/g)
console.log(haveSpace('helloworld'));//如果有空白字符就会以数组的形式返回提取出来的空白字符,如果没有空白字符就会返回null

// 判断是否有数字
const haveNumber = match(/\d+/g)
console.log(haveNumber('hcb5d6'))
// 现在我们要过滤一个数组,要找到这个数组中所有具有空白字符的元素
const filter = _.curry(function(func,array){
    return array.filter(func)
})
console.log(filter(haveSpace,['john Connor','john_Donne']));//'john Connor'
// 但是我们直接定义filter这样的意义并不大,我们还可以改造一下
//我们可以利用filter来生成这种具有特定功能的函数
const findSpace = filter(haveSpace);
console.log(findSpace(['john Connor','john_Donne']))

// 需要注意的是,函数式编程能够让我们定义一次然后可以重复性的使用
```

## 柯里化原理模拟

```
// 柯里化的实现原理
// 模拟实现lodash中的curry方法

// const _ = require('lodash')
function getSum(a,b,c){
    return a + b + c;
}
// const curried = _.curry(getSum)
// console.log(curried(1,2,3));
// console.log(curried(1)(2,3))
// console.log(curried(1,2)(3))

// curry函数内部实现

function curry (func){
    // 当传入一个普通纯函数时会返回一个新的函数
    console.log(func.length);
    return function curriedFn (...args){//标记:回调函数1
        // 判断当前函数获取到的实参的个数是否小于func的形参的个数
        if(args.length < func.length ){
            // 当是参个数小于形参个数时,
            //表示curry函数只传递了一部分参数
            // 此时返回一个新的函数
            return function(){//标记:回调函数2
                // 在这个函数中应该再次执行一些回调函数1
                // 这里我们用的是递归的方式执行curriedFn
                // 此时传递的参数应该是回调函数1的参数与回调函数2的合并值
                // 因为这个函数的参数arguments是一个伪数组,需要转换成数组
                return curriedFn(...args.concat(Array.from(arguments)))
            }
        }
        // 当实参个数大于等于形参个数时
        // 此时相当于一次性传递全部参数
        return func(...args);


    }
}
const curried = curry(getSum)
console.log(curried(1,2,3));
console.log(curried(1)(2,3))
console.log(curried(1,2)(3))


```
## 柯里化总结:
1. 柯里化可以让我们给函数传递较少的参数, 从而得到一个已经记住某些固定参数的新函数
2. 这是一种使用闭包对函数参数的缓存
3. 让函数变得更灵活,让函数的粒度更小
4. 可以把多元函数转换成一元函数,可以组合使用函数产生强大的功能

## 函数组合（compose）
![image](3A7C0AA4395043C6A412443CA1866115)

![image](73DF4DC0A51E4989B47730FE90EA42D8)

```
// 函数组合(compose)
// 函数组合演示
// 传入两个函数f和g
// 注意函数组合 组合的是纯函数,从右往左执行函数
function compose(f,g){
    return function(value){
        return f(g(value))
    }
}
function reverse(array){
    return array.reverse()
}
function first (array){
    return array[0]
}
const last  = compose(first,reverse)
console.log(last([1,2,3,4]))
```
## lodash中的组合函数
- lodash中的组合函数flow()和flowRight(),他们都可以组合多个函数
- flow()从左到右执行
- flowRight()从右到左执行
- 
```
/**
 * lodash中的函数组合方法flow和flowRight
 * flow()从左到右执行,flowRight()从右到左执行
 * 下面演示_.flowRight()方法实现获取数组中的最后一个元素并转换成大写
*/
const _ = require('lodash')
const reverse = arr => arr.reverse()
const first = arr => arr[0]
const toUpper = s => s.toUpperCase()
const getLastValue = _.flowRight(toUpper,first,reverse)
console.log(getLastValue(['hcb','pgl','hzx']))
```
## 组合函数的实现原理

```
// 函数组合的使用原理
// 模拟lodash中的flowRight方法的函数组合实现原理
const _ = require('lodash')
const reverse = arr => arr.reverse()
const first = arr => arr[0]
const toUpper = s => s.toUpperCase()
const getLastValue = _.flowRight(toUpper,first,reverse)
console.log(getLastValue(['hcb','pgl','hzx']))
// reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。
// 具体看https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce

// 模拟compose函数
// 1.传递的参数为函数
// function compose(...args){
//     // 2.用剩余参数...获取函数类参数的数组
//     // 3.返回一个函数,这个返回的函数需要做预处理,这个function中需要接受一个参数value
//     return function(value){

         
//         //4.因为函数组合中执行的函数是从右到左执行的,我们需要把函数类参数的数使用reverse翻转一下
//         // 5.然后使用reduce函数执行该数组,把每个数组中的元素去执行一个我们需要的函数,最后汇总成一个结果返回
//         return args.reverse().reduce(function(acc,fn){//参数1是上一次调用回调返回的积累结果或者初始结果,参数二是数组中正在处理的元素,在这个函数组成的数组中每个元素都是函数
//             return fn(acc)   
//         },value)
//     }
// }

// es6简写
const compose = (...args)=>value=>args.reverse().reduce((acc,fn)=>fn(acc),value);

const glv = compose(toUpper,first,reverse);
console.log(glv(['hcb','pgl','hzx']))
```

## 函数组合--结合律
函数组合要满足结合律，这个结合律是数学中的结合律，假设我们把三个函数组合成一个函数，那么我们可以把前两个函数组合，也可以把后两个函数组合，结果都是一样的
```
// 函数组合要满足结合律
const _ = require('lodash')
// const reverse = arr => arr.reverse()
// const first = arr => arr[0]
// const toUpper = s => s.toUpperCase()
// 使用lodash中的纯函数,简单方便
// const getLastValue = _.flowRight(_.toUpper,_.first,_.reverse)
// console.log(getLastValue(['hcb','pgl','hzx']))
// 下面演示结合律,当我们组合函数的时候可以先组合前两个函数也可以组合后两个函数,都是一样的
// const f = _.flowRight(_.flowRight(_.toUpper,_.first),_.reverse)
const f = _.flowRight(_.toUpper,_.flowRight(_.first,_.reverse))
console.log(f(['hcb','pgl','hzx']))
```
## 函数组合--调试

```
// 函数组合如何调试
// 案例把字符串NEVER SAY DIE 转换成 never-say-die
const _ = require('lodash');
// 检测组合函数中的函数
// const log = (v)=>{
//     console.log(v);
//     return v
// }
// 进一步确定追踪的对象
const trace = _.curry((tag,v)=>{
    
    console.log(`${tag}`,v)
    return v

})

// 去空格分割字符串转数组
const split = _.curry((spe,str)=>_.split(str,spe))
// 大写转成小写
// _.toLower
// toLower会把数组直接用逗号拼接成字符串,我们需要用map函数处理一下
const map = _.curry((fn,array)=> _.map(array,fn))
// 数组转成字符串
const join = _.curry((spe,arr)=>_.join(arr,spe))
// 函数组合
const f = _.flowRight(join('-'),map(_.toLower),trace('split之后'),split(' '))
console.log(f('NEVER SAY DIE'))


```
## lodash中的fp模块

```
// lodash中的fp模块,对函数是变成提供了友好的支持,fp模块提供的每一个方法都是柯里化的,如果有多个参数的话都是函数优先数据滞后,这些方法都可以在函数组合的时候使用
// lodash处理
const _ = require('lodash');
// 检测组合函数中的函数
// const log = (v)=>{
//     console.log(v);
//     return v
// }
// 进一步确定追踪的对象
const trace = _.curry((tag,v)=>{
    
    console.log(`${tag}`,v)
    return v

})

// 去空格分割字符串转数组
const split = _.curry((spe,str)=>_.split(str,spe))
// 大写转成小写
// _.toLower
// toLower会把数组直接用逗号拼接成字符串,我们需要用map函数处理一下
const map = _.curry((fn,array)=> _.map(array,fn))
// 数组转成字符串
const join = _.curry((spe,arr)=>_.join(arr,spe))
// 函数组合
const f = _.flowRight(join('-'),map(_.toLower),trace('split之后'),split(' '))
// console.log(f('NEVER SAY DIE'))

//------------------------------------------------------------------------------
// fp模块处理
// fp模块简化,减少了上面各种方法的包装
const fp = require('lodash/fp');
const f2 = fp.flowRight(fp.join('-'),fp.map(fp.toLower),fp.split(' '))
console.log(f2('NEVER SAY DIE'))
```
## lodash-map方法的小问题

```
// lodash 和lodash/fp 模块中 map 方法的区别

//区别:所接收的函数的的参数不一样,lodash中map的函数所接收参数是三个,fp中的map所接收的参数是一个

// 调用map方法把数组中的所有元素都转换成整数
// lodash的处理方式
const _ = require('lodash')

console.log(_.map(['23','8','10'],parseInt));//[ 23, NaN, 2 ]
// 为什么会打印出NaN呢?
// 鼠标放在map上我们可以看到该方法的解释中有这么一段话Creates an array of values by running each element in collection through iteratee. The iteratee is invoked with three arguments: (value, index|key, collection).
// map的第二个参数是一个函数,函数必须有三个参数:值,索引/键,集合
// 下面我们展开一下map调用perseInt方法的过程
_.map(['23','8','10'],function(value,index,array){
    // console.log(value,index,array)
    // parseInt(string, radix)   将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。
    // perseInt的两个参数分别是string(被解析的字符串),radix(几进制)
    // 按顺序传递参数给parseInt会造成value对标string,index对标radix
    return parseInt(value,index,array)
})
// 这样造成的结果就是
// parseInt('23',0,array)
// parseInt('8',1,array)//8为1进制,不存在的,进制的范围是2-36,所以返回的是NaN
// parseInt('10',2,array)

// 解决上面的问题可以自己封装一个parseInt,只接受一个参数,这样就可以解决了

//------------------------------------------
// fp模块的map方法就不会出现这样的问题
const fp = require('lodash/fp')
// fp模块的map方法只传递一个参数的时候接收的是一个函数,因为fp模块中的方法是函数优先的,当前这甘薯只接收一个参数,而lodash中的函数所接收的参数是三个
console.log(fp.map(parseInt,['23','8','10']))

```
## Point Free

```
// point free
/**
 * Point Free 概念:我们可以把数据处理的过程定义成与数据无关的合成运算,不需要用到代表数据的那个参数,只要把简单的运算步骤合成到一起,在使用这种模式之前我们需要定义一些辅助的基本运算函数.
 * 
 * 重点关注下面三句话:
 * 1.不需要指明处理的结果
 * 2.只需要合成运算过程
 * 3.需要定义一些辅助的基本运算函数
 * 
*/


// hello World => hello_world
// 两个步骤:
// 1.转换成小写
// 2.把空格替换成_
const fp = require('lodash/fp')
const aToB = fp.flowRight(fp.replace(/\s+/g,'_'),fp.toLower)
console.log(aToB('hello World'))
```
## Point Free案例

```
// point free 案例
//把一个字符串中的首字母提取并转换成大写,使用.号分隔符
// world wild web ==> W.W.W
const fp = require('lodash/fp')
// const aToB = fp.flowRight(fp.join(', '),fp.map(fp.first),fp.map(fp.toLower),fp.split(' '))
// 上面我们调用了两次map,如何能值调取一个map?看下面
const aToB = fp.flowRight(fp.join(', '),fp.map(fp.flowRight(fp.first,fp.toLower)),fp.split(' '))
console.log(aToB('world wild web'))
```
## functor（函子）
![image](5DADBE7FDAB24C4E87973F51FEAE1E88)
```
//functor 函子,把副作用控制在可控范围内, 函子可以处理异常和异步操作
// 函子是一个特殊的容器,通过一个普通的对象来实现,该对象 具有map方法,map方法可以运行一个函数对值进行处理(变形关系)

// 函子是一个对象,并且维护一个值,对外公布map方法

// class Container {
//     constructor(value){
//         // 现在函子这个盒子里要维护一个值,这个值不对外公布 
//         this._value = value
//     }
//     // 现在我们对外公布map方法,接收一个处理值得函数
//     // 这个函数是纯函数,因为我们要把value传递给这个函数,由这个函数来处理这个值
//     map(fn){
//         // 当我们调用map方法的时候,map方法会调用fn处理这个值,并且把处理的结果返给一个新的函子,由新的函子来保存
//         // 返回一个新的值的时候,我们把fn函数处理的值传递给Container
//         return new Container(fn(this._value))
//     }
// }
// let r = new Container(5)
//     .map(x=>x + 1)
//     .map(x => x * x)
// console.log(r)
// //所以我们的map方法返回的不是值而是一个新的函子对象,在这个新的函子对象里面保存一个新的值,我们始终不把值对外公布,我们想要处理值的话就要给map对象传递一个处理值得函数

//----------------------如何不使用new实例化Container呢?
// 在Container中创建静态方法,返回实例化 的Container
class Container {
    static of(value){
        return new Container(value)
    }
    constructor(value){
        this._value = value
    }
    map(fn){
        return Container.of(fn(this._value))
    }
}
let r = Container.of(5)
    .map(x=>x + 2)
    .map(x => x * x)
console.log(r)
// ---------------------------
// 如果 给函子传递null undefined就会报错 ,怎么解决这类问题?
Container.of(null)
    .map(v=>v.toUpperCase())

```
## 函子总结
![image](28F9800C8F3B4269B044A447AD3D22D9)

## Maybe函子（处理空值的问题）
- 我们在编程过程中可能会遇到很多错误，需要对这些错误做相应的处理
- MayBe函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

```
// MayBe 函子 处理空值的问题
class MayBe {
    constructor (value){
        this._value = value
    }
    static of(value){
        return new MayBe(value)
    }
    map(fn){
        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))
    }
    // 判断传入的值是不是null或undefined
    isNothing(){
        return this._value === null || this._value === undefined
    }
}
const m = MayBe.of('hello world')
    .map(v=> v.toUpperCase())
// console.log(m);//MayBe { _value: 'HELLO WORLD' }
const b = MayBe.of(null).map(v => v.toUpperCase())
// console.log(b)//MayBe { _value: 'null' }
// -----------------------------------------

// maybe函子的问题:当我们多次调用map的时候我们不知道哪一次传入了空值 
const c = MayBe.of('hello world')
    .map(v=> v.toUpperCase())
    .map(v=> null)
    .map(v=> v.split(' '))
    console.log(c)
```
## Either函子
- Either两者中的任何一个，类似if...else...的处理
- 异常会让函数变得不纯，Either函子可以用来处理异常

```
// Either函子,处理异常问题并且可以记录下来出错的信息
class Left {//left用来处理异常
    static of(value){
        return new Left(value)
    }
    constructor(value){
        this._value = value
    }
    map(fn){
        return this;//返回对象本身
    }
}
class Right {//用来处理正确的值
    static of(value){
        return new Right(value)
    }
    constructor(value){
        this._value = value
    }
    map(fn){
        return Left.of(fn(this._value))
    }
}
function parseJson (value){
    try {
        return Right.of(JSON.parse(value))
    } catch (error) {
        return Left.of({error:error.message})
    }
}
// let r = parseJson('{hcb:hhh}')
let r = parseJson('{"hcb":"hhh"}')
        .map(x => x.hcb.toUpperCase())
console.log(r)
```
## IO函子


 
- IO函子中的_value是一个函数,这是把函数当做值来处理
- IO函子可以把不纯的动作存储到_value中,延时执行这个不纯的操作(惰性操作),包装当前纯的操作
- 把不纯的操作交给调用者来处理


```

const fp  = require('lodash/fp')
class IO {
    static of(value){
        return new IO(function(){
            return value
        })
    }
    constructor(fn){
        this._value = fn
    }
    map(fn){
        // 这里使用new IO的构造函数而不是使用IO.of方法是因为在map方法里面我们需要把当前函子的value也就是这个函数和我们传入的这个函数组合成一个新的函数,而不是去调用函数处理值,这是跟以前不一样的地方
        return new IO(fp.flowRight(fn,this._value))
    }
}
const r = IO.of(process)//当我吗调用of方法时,它会把我们传入的值包装在一个函数里来,当我们需要的时候再来获取这个值
    .map(p=>p.execPath)
    console.log(r);//IO { _value: [Function] }
    //我们当前调用完这个函数之后会返回一个IO函子,这个IO函子的value保存的是一个function,我们可以直接调用一下
    console.log(r._value())//:\Program Files\nodejs\node.exe当前进程的路径
```
## folktale
### Task异步执行
- 异步任务的实现过于复杂，我们使用folktale中的task来演示
- folktale是一个标准的函数式编程库
    - 和lodash、ramda不同的是，他没有提供很多功能函数
    - 只提供了一些函数式处理的操作，例如compose、curry等，一些函子Task、Either、MayBe等

```
// folktale是一个 函数式编程库,其中的 task方法可以处理异步操作的问题
// 下面 我们来看一下folktale中的compose和curry 
const { compose , curry } = require('folktale/core/lambda')
const { toUpper ,  first } = require('lodash/fp')
// folktale中的curry和lodash 中的curry还是有些区别的
// 柯里化curry
// curry的第一个参数 声明传递的参数个数,第二个参数是传入的函数
// let f = curry(2,(x,y)=>{
//     return x + y
// })
// console.log(f(1,2))
// console.log(f(1)(2))
// -------------------------------------
// compose(函数组合)
let f = compose(toUpper,first)
console.log(f(['ind','hcb']))
```
## Task函子
### Task异步执行
- folktale(2.3.2)2.x中的Task和1.0中的Task区别喊打，1.0中的用法更接近我们现在演示的函子
- 这里用2.3.2来演示

```
// task 处理异步任务
// 案例通过读取文件演示异步任务
// 读取package.json文件,并把version解析出来
// task在folktale^2.0版本提供的是函数 形式,在folktale^1.0版本提供的是类
const { task } = require('folktale/concurrency/task')
//  node环境读取文件使用fs模块
const fs = require('fs');

//切割 package.json并找到version需要用到lodash/fp模块的split和find
const { split , find } = require('lodash/fp') 

// 写一个读取文件的函数
function readFile(filename){//传入文件的路径,同层相对路径可以直接写名字
    // 返回一个task函子,task函数的返回值是一个Task对象,
    // task函数本身需要接收一个函数,这个函数的参数时固定的叫resolver
    
    return task(resolver =>{
        // resolver是一个对象,提供了两个方法
        // resolve执行成功调用的方法
        // reject执行失败调用的方法

        //fs.readFile是异步读取文件
        fs.readFile(filename,'utf-8',(err,data) =>{
            // 先判断读文件的时候是否出错了,如果出错调用resolver.reject方法
            if(err) resolver.reject(err)
            // 如果执行成功调用resolver.resolve方法
            resolver.resolve(data)
        }) 
    })
}

// 执行读取文件的函数,当我们读取文件的时候返回的是一个task函子
// readFile('package.json')
// // 想要读取文件的话调用Task函子中的run方法
//     .run()
// // Task函子还提供了监听事件方法listen(),用来接收resolve和reject的值
//     .listen({
//         onRejected : err =>{
//             console.log(err)
//         },
//         onResolved: value=>{
//             console.log(value)
//         }
//     })
    // 执行node命令可以看到读出来的文件
//------------------------------------------------

//我们知道readFile方法返回的是一个Task函子,而Task函子都有一个map方法
//所以在run直接我们可以调用Task函子的map方法,在map方法里面来处理拿到的结果
readFile('package.json')
// 切割换行符,截取字符串返回数组
    .map(split('\n'))
// 通过find方法查找数组中的每一项是否具有version
    .map(find(x => x.includes('version')))
    .run()
    .listen({
        onRejected : err =>{
            console.log(err)
        },
        onResolved: value=>{
            console.log(value)
        }
    })
```
## point函子
![image](486F4B49DE92416DA9AB612C6E94DD09)
![image](80630BFB09DC4609B01C2D237D56009A)

## IO函子的问题

```
/**
 *  IO 函子 的问题
 * IO函子回顾 :
 * IO函子中的_value是一个函数,这是把函数当做值来处理
 * IO函子可以把不纯的动作存储到_value中,延时执行这个不纯的操作(惰性操作),包装当前纯的操作
 * 把不纯的操作交给调用者来处理
 * 
*/
const fs = require('fs');
const fp  = require('lodash/fp')
class IO {
    static of(value){
        return new IO(function(){
            return value
        })
    }
    constructor(fn){
        this._value = fn
    }
    map(fn){
        // 这里使用new IO的构造函数而不是使用IO.of方法是因为在map方法里面我们需要把当前函子的value也就是这个函数和我们传入的这个函数组合成一个新的函数,而不是去调用函数处理值,这是跟以前不一样的地方
        return new IO(fp.flowRight(fn,this._value))
    }
}
// const r = IO.of(process)//当我吗调用of方法时,它会把我们传入的值包装在一个函数里来,当我们需要的时候再来获取这个值
//     .map(p=>p.execPath)
//     console.log(r);//IO { _value: [Function] }
//     //我们当前调用完这个函数之后会返回一个IO函子,这个IO函子的value保存的是一个function,我们可以直接调用一下
//     console.log(r._value())//:\Program Files\nodejs\node.exe当前进程的路径

// // ----------------------------------------
// linux下有一个cat命令,这个命令的作用是读取文件的内容,
// 并且把内容打印出来,下面模拟一下这个命令
// 先写一个读取文件的函数,再写一个打印的函数,然后组合成一个cat函数
let readFile = function(filename){
    return new IO(function(){
        return fs.readFileSync(filename,'utf-8')
    })
}
let print = function(x){
    return new IO(function(){
        console.log(x)
        return x;
    })
}
let cat = fp.flowRight(print,readFile);
// IO(IO(x))//返回的是 嵌套函子
let r = cat('package.json')._value()._value()
console.log(r)
/**
 * IO函子的问题:
 * 我们在调用嵌套函子的时候非常不方便,如果函子有嵌套的话,
 * 我们想要调用嵌套函子中的函数,我们需要._value()._value(),
 * 虽然这样也可以实现,但是这种api的风格看起来很不爽
 */
```

## Monad函子
- Monad函子是可以变扁的Ponit函子,可以解决函子嵌套的问题,
- 一个函子如果具备join和of两个方法并遵守一定的 定律就是Monad
```
/**
 *  Monad解决   可以IO 函子 的问题
 * Monad函子是可以变扁的Ponit函子,可以解决函子嵌套的问题,
 * 一个函子如果具备join和of两个方法并遵守一定的 定律就是Monad
 * IO函子的问题:
 * 
 * IO函子的问题:
 * 我们在调用嵌套函子的时候非常不方便,如果函子有嵌套的话,
 * 我们想要调用嵌套函子中的函数,我们需要._value()._value(),
 * 虽然这样也可以实现,但是这种api的风格看起来很不爽
 */

const fs = require('fs');
const fp  = require('lodash/fp')
class IO {
    static of(value){
        return new IO(function(){
            return value
        })
    }
    constructor(fn){
        this._value = fn
    }
    map(fn){
        // 这里使用new IO的构造函数而不是使用IO.of方法是因为在map方法里面我们需要把当前函子的value也就是这个函数和我们传入的这个函数组合成一个新的函数,而不是去调用函数处理值,这是跟以前不一样的地方
        return new IO(fp.flowRight(fn,this._value))
    }
    join () {
        return this._value()
    }
    flatMap(fn){
        // 该方法的作用就是同时调用map和join
        return this.map(fn).join()
    }
}


// linux下有一个cat命令,这个命令的作用是读取文件的内容,
// 并且把内容打印出来,下面模拟一下这个命令
// 先写一个读取文件的函数,再写一个打印的函数,然后组合成一个cat函数
let readFile = function(filename){
    return new IO(function(){
        return fs.readFileSync(filename,'utf-8')
    })
}
let print = function(x){
    return new IO(function(){
        console.log(x)
        return x;
    })
}
let r = readFile('package.json')
            .map(x=>x.toUpperCase())
            .flatMap(print)
            .join()
console.log(r)
/**
 * 什么是monad?
 * 就是一个具有静态的IO方法并且具有专业方法的这么一个函子
 * 什么时候使用monad呢?
 * 让一个函数返回一个函子的时候,我们要想到monad
 * monad可以帮我们解决函子嵌套的问题
 * 当我们想要合并一个函数,并且这个函数返回一个值,
 * 这个时候我们可以调用map方法
 * 当我们想要去合并函数,但是这个 函数返回一个函子,
 * 这个时候我们要用flatMap方法
 */
```

## 课程概述
接下来我要介绍的是JavaScript的系统优化，我们都知道，随着软件开发行业的不断发展，性能优化呢，已经是一个不可避免的话题，那什么样的行为才能算得上是性能优化呢？本质上来说，任何一种可以提高运行效率，降低运行开销行为，我们都可以看到这种优化操作，这就意味着，在软件开发过程中必然存在很多值得优化的地方，特别是在前端应用开发过程中，性能优化是无处不在的，例如请求资源时所用到的网络，以及数据的传输方式，在负责开发过程中所使用的框架等，他们都可以去优化的，本阶段我们要探索的是JavaScript的语言本身的优化，具体来说就是从认知内存空间的使用，再到垃圾回收的方式介绍，从而呢可以编写出高效的JavaScript代码，那么，下面我们就来看一下在性能优化阶段，我们会涉及到哪些内容，首先第一部分的我们会具体到内存管理，在这里呢，我们首先会说明为什么我们内存是需要管理的以及内存管理的基本流程，同时呢，我们也会介绍一些常见的GC算法，让你可以灵活的去应对一些所谓的大厂面试，但是之后呢，我们还会介绍当前世界上非常流行的V8引擎，那么我们会具体介绍可以把引擎当中使用的是什么样的GC算法在实现我们当前的垃圾回收，那么接下来让我们了解了内存管理以及垃圾回收相关的操作之后，我们会通过Google浏览器所提供一些工具，例如Performance来具体的演示一下如何去对内存进行监控，从而去发现我们当前代码中是否存在都可以优化的性能空间，最后我们会通过一些具体的代码示例来做演示，我们可以具体的去完成一些代码层面的优化操作，那一块呢，就是针对于性能优化相关的一些内容介绍。

![image](5457BC54FD9C4EA0B2AC54FA3A17FB2E)

## 内存管理
### 内存为什么需要管理
我来看一下JavaScript内存管理相关内容，随着近些年硬件技术的不断发展，同时高级编程语言当中也都自带了GC机制，所以这样一些变化，让我们再不需要特别注意内存空间使用情况下也能够去正常地完成相应的功能开发，那么为什么在这里我们一定要去重提内存管理呢？下面我们通过一段简单的代码来进行说明，


```
function fn(){
    arrList = []
    arrList[10000] = 'lg is a coder'
}
fn()
```

需要注意的就是我们在赋值的时候特意选择一个比较大的数字。这样做的目的呢，就是为了当前这个函数在调用的时候可以向我们的内存呢，尽可能多的申请一片比较大的空间，


![image](564838E91F1B4D45BC7DFD1DA63C09A1)


然后我们再执行这个函数过程中，其实从语法上来说呢，它是不存在任何问题的，不过当我们用相应的一个性能监测工具来在这个脚本执行过程中对他的内存进行监控的时候，我们会发现，那么它的内存变化，就我们当前图中所看到的一个蓝色线条一样，但是持续升高的那在这个过程当中并没有看到回落，那么这代表着什么呢？非常简单，就是一个内存泄露，至于说他如何泄露的，我们现在不需要纠结。

我们想要声明的是，如果说我们在写代码的时候不够了解内存管理这些机制，那么就会让我们去编写出一些不容易察觉到的内存问题性代码，那像这种代码多了以后呢，给程序带来的可能就是一些意想不到的bug，所以掌握内容的管理呢，还是非常有必要的
### 什么是内存管理？

![image](9D4676D030A7462294AFA574103432AC)

###JavaScript中的内存管理

![image](FE8749FD395F4F62852823FEDAF8A23D)
它也是分三步来执行这一过程，但是呢，由于ECMAscript当中呢，并没有提供相应的操作api，所以在这一点呢，不能像C或者C++一样主动的去调用相应的api来完成这样的空间管理，不过即使如此，他也不能影响我们去通过js脚本来演示当前在内部一个空间的生命周期是怎样完成的，所以下边呢，我们就回到编辑器当中来，通过一段简单的js脚本的演示一下我们当前的一个内存空间的生命周期是什么样子的？

```
// 内存管理

// 申请空间
let obj = {}
// 使用空间
obj.name = 'hcb'
// 释放空间
obj = null;
```

## JavaScript中的垃圾回收
![image](0A11BC7482804B2AA72F0AF810A31587)

![image](25C8A28C562E4B23A6B91EC355693D6C)

javascrip的垃圾回收就是找到垃圾，让js引擎进行空间的释放和回收，通这里用到了引用和可达对象实。

下面看一下js中的引用和可达


```
// js中的引用

// 引用说明和部分可达说明
let obj = {name:'xm'};//obj引用了这个对象空间，同时xm是可达的
let ali = obj;//ali通过obj引用了obj的对象空间
obj = null;//obj为空的时候，xm还是可达的对象，因为ali还在引用xm的对象空间
```

```
//可达
function objGroup(obj1,obj2){
    obj1.next = obj2
    obj2.prev = obj1
    return {
        o1:obj1,
        o2:obj2
    }
}
let obj = objGroup({name:'obj1'},{name:'obj2'})
console.log(obj)
//{ o1: { name: 'obj1', next: { name: 'obj2', prev: [Circular] } },
//o2: { name: 'obj2', prev: { name: 'obj1', next: [Circular] } } }
```
下面是演示图

![image](E1A9A4001E7D428DB799C2073A19FE41)

当对象的访问路径被破坏或删除就会造成垃圾回收，红色线条表示delete

![image](D5ACBE5953DB4FBDAE416C7037D7631A)

## GC算法介绍

![image](E69964F93CA54C818C627BE6D463C250)

![image](30DFE2FB89DE49D2A54E8DE5B583B162)

![image](DD1AEB203DD848D88F6FE1958EAC7A2F)

![image](1B70B96B58D747EFB6A24BE8D8321D00)

## 引用计数算法实现原理

![image](7A1E5C4FC9FD40A69356A859BAC620E2)
假设有一个对象空间，有一个变量名指向它，计数器就+1，减少一个指向就-1，到0的时候就回收对象空间

```
// 引用计数器实现原理

const u1 = {a:1}
const u2 = {a:2}
const u3 = {a:3}

const uList = [u1.a,u2.a,u3.a]
function(){
    const n1 = 1;
    const n2 = 2;
}
fn();//调用后销毁，
```
上面代码就是根据当前对象的引用数值来计算是不是垃圾对象

## 引用计数算法的优缺点
### 优点
![image](A88407D9322744FA9134A1458E310DFF)

> 最大限度减少程序暂停是指应用程序在运行时必然会消耗内存，而我们当前的执行平台的内存是有上限的，所以内存肯定有暂满的时候，不过，由于引用计数算法时刻监控着那些引用计数的对象，所以当某一个对象即将爆满的时候，引用对象立刻会找到数字为0的空间进行释放，这样就保证了我们当前内存不会有暂满的时候，这也就是所谓的减少程序暂停的说法

### 缺点
![image](A9820B5E684D42B083063D7855A700ED)

> 引用计数时间开销大是因为引用计数器需要维护数值的变化，时刻监视当前对象的引用数值是否修改，本身来说，对象引用数值的修改就需要消耗时间，对象越多，时间越大


```
// 循环引用的对象无法回收
function fn(){
    const obj1 = {}
    const obj2 = {}
    obj1.name = obj2
    obj2.name = obj2
    return 'hh'
}
fn()
```

## 标记清除算法的实现原理
![image](3D3C2AF14687478DB6D674E4347B940B)

![image](9244B7B1AEDB409CADC2D0BA60838F20)
> 找到所有可达对象，把所有没标记的对象全部清除释放空间， 回收的空间会放在空闲列表上面，方便使用

## 标记清除算法的优缺点
### 优点
- 相对于引用计数来说，解决对象循环引用的回收操作

![image](7327863A7AD0436292B6418ACAC51DAB)

### 缺点
- 相对于垃圾回收，导致内存地址不连续，产生空间碎片化问题，不能让空间得到最大化的使用
- 标记清除不会立刻回收垃圾对象，因为标记清除的时候程序是停止运行的
![image](7F146987654E45908FD3EAF24005D0F3)
![image](AF9972756AED4F078103FE51979DE55B)

## 标记整理算法实现原理
![image](10983B414EE64152A83C013402230993)
![image](704351D976F440EF894CA29292F6EA2F)
![image](07070D15C4BD4DAF944B46B2EF1194E4)

相对于标记清除算法来说，好处显而易见，不会大批量出现分散的小空间，而回收到的空间基本上都是连续的，在后续的使用中，想去申请的时候就可以尽可能的利用内存当中所释放出来的空间

> 在v8引擎中一般会配合标记清除来使用

## GC算法总结

![image](1E11E93F4AC844F39E82AFDD7218A351)

![image](FF77DC0F2DF24AF0BF8D2E8138E12C39)

![image](9EF83E3E36F74B1BA9AE5346907F64B7)

## 认识V8

![image](2B491F639C664416A8E6712D2D128FD7)

V8内存上限在64位操作系统不超过1.5G，32位操作系统不过超过800M，为什么呢？因为V8本身就是位浏览器制造的，所以现有的内存大小对于网页来说是足够使用了，再有V8内部的垃圾回收机制决定这样的设置是合理的

## V8垃圾回收策略
垃圾回收指的是回收存在堆区里的数据，这个过程是离不开对内存的操作的，
V8引擎的内存有上限，所以采用分代回收的思想吧内存分为新生代存储区和老生代存储区，针对不同代采用最高效的GC算法，从而对不同的对象进行垃圾回收操作

![image](0F52B356E585489BB3C8E39D86D8B21F)

![image](956D6E7A31934EA8B4525700F668DD5F)


## V8如何回收新生代对象
![image](C3FDCFFB4A2842B09AE3DA8B04E3D442)
### V新生代对象说明
- V8空间一分为二
- 小空间用于存储新生代对象（64位操作系统32M|32位操作系统16M）
- 新生代指的是存活时间较短的对象
> 如何鉴定存活时间较短？比如当前代码有一个局部作用域，局部作用域的变量在执行过后就会被回收，而全局作用域的变量在代码全部结束后回收，新生代指的就是那些存活比较短的对象

### 新生代对象回收实现

![image](F13C925DE3EC4AA893FA95A8889AF474)

### 回收细节说明
![image](5DFE55D1BA624672BBB8C7FF8207671C)

> to空间的使用率超过25%会造成form与to交换的时候空间不足

## V8如何回收老生代对象
### 老生代对象说明
- 老生代对象存放在右侧老生代区域
- 64位操作系统1.4G，32位操作系统700M
- 老生代对象指的是存活时间较长的对象，如全局变量和闭包
### 老生代对象回收实现
- 主要采用标记清除、标记整理、增量标记算法
- 首先用标记清除完成对垃圾空间的回收，虽然会存在空间碎片，但是提升速度恨明显
- 当新生代对象区域的内容往老生代区域进行移动的时候，而且这个时间节点，老生代存储区又不足以存放新生代存储区移过来的对象，也就是晋升，这种情况下就会触发标记整理算法把之前的碎片空间进行整理 回收，这样就让我们有更多的空间可以使用
- 采用增量标记对回收效率进行提升
### 老生代和新生代细节对比
![image](83A94162A56245189A8DE7828D9D2A5E)

### 增量标记如何优化垃圾回收

![image](D1093F320EA24A47B1BE8C87BB787FAB)
> 需要注意的是，垃圾回收会阻塞程序的执行，这里会有一个空档期，程序执行结束后会执行垃圾回收操作
> 所谓的标记增量是指将一整段的垃圾回收操作拆分成多个小部分，组合的去完成垃圾回收，从而呢替代之前一口气做完的垃圾回收操作，这样做的好处是实现垃圾回收和程序执行的交替过程，而不像以前那样程序执行的时候就不能进行垃圾回收，而进行垃圾回收的时候就不能进行程序的运行，这个时候来的消耗就更加合理一些

## Performance工具介绍
### 为什么使用Performance？
1. OC的目的是为了实现内存空间的良性循环
2. 良性循环的基石是对内存空间的合理使用，
>由于ECMAscript并没有提供内存空间相应的api，所以是否合理呢也都不知道，因为内存管理都是由GC操作的，所以想判断内存使用的是否合理得关注我们内存的使用变化
3. 时刻关注才能确定是否合理
4. Performance提供了多种监控方式

> 通过performance可以时刻监控内存

### Performance使用步骤
![image](66B7273907DE4784941D3033A829BFE8)
![image](9652A1EAEB684405945B83017925EEB3)
![image](13E91AA8A3974F009D02522767B05995)
> 使用Performance工具能够让我们时刻监控程序运行时内存变化，从而发现内存的问题，辅助我们能够在代码当中做些变化，从而提高代码的效率

## 内存问题的体现
### 内存问题的外在表现
- 页面出现延迟加载或经常性暂停
- 页面持续性出现糟糕的性能，就是不好用，这个时候一般认为底层出现内存膨胀，所谓的内存膨胀指的是当前界面为了达到最佳的使用速度，可能会去申请一定的内存空间，但是这个内存空间大小超过了本身内存空间的大小，这个时候就会感知到一段持续性的糟糕体验，同样我们假设当前定的网络环境是正常的
- 页面的性能随着时间延长越来越差，也就是界面使用的流畅度随着时间的加长越来越慢，越来越差，这个时候就伴随着内存的泄露，在这种情况下我们刚开始的时候是没有问题的，由于某些代码的出现，可能随着时间的增长让我们的内存空间是越来越少，这就是所谓的 内存泄漏，因此在这种时候随着页面使用时间越差性能越差

## 监控内存的几种方式
### 当我们内存出现问题的三种情况：
1. 内存泄漏
2. 内存膨胀
3. 频繁的 垃圾回收

### 鉴定问题的标准
- 内存泄漏：内存使用持续升高，根据内存走势图去判断，当内存走势持续升高没有下降的节点，这就意味着内存当中存在这泄漏的，这个时候应该去代码里面定义这样的模块
- 内存膨胀：在多数设备上都存在性能问题。指的是当前程序本身为了达到一个最优的效果需要很大的一个内存空间，所以在这个时候有可能是当前设备的硬件不支持，从而造成使用过程中出现性能的差异如果想要判定是程序的问题还是说是设备问题，就应该多做一些测试，这个时候就可以找到那些深受用户喜爱的设备，然后在上边都去运行我们的应用程序，如果整个过程中，所有的设备都表现出糟糕的用户性能体验，这就说明我们程序本身是有问题的，而不是设备有问题，这种情况应该回到代码里面定位出现问题的地方
- 频繁垃圾回收：通过内存变化图进行分析

### 监控内存的几种方式
- 浏览器任务管理器
- Timeline时序图记录
- 堆快照查找分离DOM，分离DOM存在也是内存泄漏
- 判断是否存在频繁的垃圾回收

## 任务管理器监控内存

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>任务管理器监控内存变化</title>
</head>
<body>
    <button id="add">add</button>
	<script>
		const oAdd = document.getElementById('add')
		oAdd.onclick = function(){
			let newList = new Array(1000000)
		}
	</script>
</body>
</html>
```
> 下面是edge浏览器打开的任务管理器

![image](A55F85A85E0541CF98D4E48BB42AB445)

> chrome 在浏览器打开当前html，shift + sec 打开任务管理器，如果没有JavaScript内存这一列可以右击任务管理器调出来，第一列内存表示DOM节点所占据的内存，也就是原生内存，如果数量不断的增多，那么说明我们在不断的新建DOM，最后一列JavaScript内存，表示js堆，我们需要关注的是小括号的值，它表示所有可达对象正在使用的内存大小，如果说这个数值在增大，意味着我们当前的键中要么在创建新对象，要么是当前现有对象不断在增长，我们可以通过任务管理器监控js脚本整个运行的变化，如果js堆中小括号中的内存不断增大就意味着我们的内存是有问题的，但是浏览器任务管理器只能判断有没有问题，具体问题是什么看下一节！

## Timeline记录内存
通过时间线计算内存变化的方式来演示我们怎么更精确的定位当前的问题跟那块代码是相关的，或者说在什么时间节点发生的

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Timeline记录内存</title>
</head>
<body>
    <button id="add">add</button>
	<script>
		const arrList = []
		function test(){
			for(let i = 0 ; i < 10000 ; i++){
				document.body.appendChild(document.createElement('p'))
			}
			arrList.push(new Array(10000).join('x'))
		}
		const oAdd = document.getElementById('add')
		oAdd.onclick = test;
	</script>
</body>
</html>
```

![image](64C50BC5D32145F59EC96BB8146D759F)

## 堆快照查找分离DOM
### 堆快照功能的工作原理
首先找到当前的js堆，然后呢对它进行一个照片的留存，有了照片以后可以看到所有的信息，这就是如何去监控的由来。

堆快照非常有用，是一个专门针对分离DOM的查找行为

### 什么是分离DOM
- 界面元素存活在DOM树上
- 垃圾对象时的DOM节点：这个对象从DOM树上脱离，js也没有再引用这个节点
- 分离状态的DOM节点：这个对象从DOM树上脱离，但是js还在引用这个节点，分离DOM在js上是看不见的，但在内存是占据空间的，这是一种内存的浪费，所以这种情况下就是内存泄漏，因此我们可以用堆快照的功能从内存中找出来，找到后回到代码里针对代码进行清除，从而让我们当前的内存得到释放，脚本在执行的时候也会更加迅速


```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>堆快照查找分离DOM</title>
</head>
<body>
    <button id="add">add</button>
	<script>
		var templates;
		function test(){
			let ul = document.createElement('ul')
			for(let i = 0 ; i < 10000 ; i++){
				ul.appendChild(document.createElement('li'))
			}
			templates = ul;
		}
		const oAdd = document.getElementById('add')
		oAdd.onclick = test;
	</script>
</body>
</html>
```
打开审查元素，点击内存可以看到

![image](014306557089441EA79E145D9FBAB4CE)

没有点击add按钮的时候拍一下，搜索简写deta

![image](CAEB9A45A0FA4F6499B605944F70BE4C)

点击两下add按钮后，返回初始页，点击拍照，搜索deta，看到

![image](834D67A34B194A1281DD98C46216FD76)

这就是我们脱离DOM树但还被js引用的DOM，怎么清除呢？

```
templates = null
```
![image](5AD47C6E39C045FDBD6D86A257112FF7)

## 判断是否存在频繁的垃圾回收
### 为什么确定频繁垃圾回收
- GC工作时应用程序是停止的
- 频繁且过长的GC会导致应用假死
- 用户使用中感知应用卡顿

## 确认频繁的垃圾回收
- TImeline中频繁的上升下降
- 任务管理器中数据频繁的增加减小

## 代码优化介绍
### 如何精准测试JavaScript性能
- 本质上就是采集大量的执行样本进行数学统计和分析，从而得出一个比对的结果，来证明什么样的脚本效率更高
- 使用基于Benchmark.js的脚本网站实现在线的性能测试

> [性能测试网址](https://jsperf.com/)
### Jsperf使用流程
![image](4258BCF8A9CA4D9B98FE482788532EDB)

## 慎用全局变量
在程序中如果针对某些数据进行存储，那么尽可能的放在局部作用域当中，变成一个局部变量
### 为什么慎用全局变量？
- 当我们在全局定义一个变量，它就在全局的上下文当中，这个上下文就是我们在后续程序查找过程中的所有作用域链的最顶端，如果在下面没有找到，会一直往往上找，这样一来，时间的消耗会很大，降低了当前代码的执行效率
- 全局执行上下文一直存活于上下文执行栈，直到程序退出才会消失，这对当前的GC工作也是非常不利的，因为只要我们的GC发现这样一个变量还处于一个存活的状态，就不会把它当做垃圾对象进行回收，因此这样也会降低当前程序运行时对于内存的使用，除此以外
- 如果某个局部作用域出现了同名变量怎会遮蔽全局变量或污染全局变量

### 下面我们根据全局变量和局部变量存储做个对比，看看两者执行的性能差异

```
// 全局
var i,str = ''
for(i = 0;i<1000;i++){
	str += i
}
// 局部
for(let i = 0 ; i < 1000 ; i++){
	
	let str = ''
	str += i
}
```
![image](FE02BA8498914EBB99BE704C517A7DFB)

## 缓存全局变量
### 如何通过缓存全局变量提高代码的执行性能？
将使用中无法避免的全局变量缓存到局部，提高js代码的执行性能
### 下面看看在DOM操作中采用DOM缓存和不采用DOM缓存的性能差异有多大

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>缓存全局变量</title>
</head>
<body>
    <button id="add1">add1</button>
	<button id="add2">add2</button>
	<p>aaa</p>
	<button id="add3">add3</button>
	<button id="add4">add4</button>
	<p>bbb</p>
	<button id="add5">add5</button>
	<button id="add6">add6</button>
	<p>ccc</p>
	<button id="add7">add7</button>
	<button id="add8">add8</button>
	<script>
		// 全局变量不缓存
		function getAdd(){
			let oAdd1 = document.getElementById('add1')
			let oAdd2 = document.getElementById('add2')
			let oAdd3 = document.getElementById('add3')
			let oAdd4 = document.getElementById('add4')
			let oAdd5 = document.getElementById('add5')
			let oAdd6 = document.getElementById('add6')
			let oAdd7 = document.getElementById('add7')
			let oAdd8 = document.getElementById('add8')
		}
		// 全局变量缓存到局部
		function getAdd2(){
			const obj = document
			let oAdd1 = obj.getElementById('add1')
			let oAdd2 = obj.getElementById('add2')
			let oAdd3 = obj.getElementById('add3')
			let oAdd4 = obj.getElementById('add4')
			let oAdd5 = obj.getElementById('add5')
			let oAdd6 = obj.getElementById('add6')
			let oAdd7 = obj.getElementById('add7')
			let oAdd8 = obj.getElementById('add8')
		}
	</script>
</body>
</html>
```
![image](0F7D491E331D43BD86FB2871FB9C6C5C)

## 通过原型对象添加附加方法
### 对比在构造函数内部添加方法和在原型对象上添加方法的性能差异
![image](3EEE4D41B448441CB5E23B4261697ABF)

## 避开闭包陷阱
### 闭包特点
- 外部具有指向内部的 引用
- 在“外”部作用域访问“内”部作用域的数据

```
function foo(){
    var name = 'lg'
    function fn(){
        console.log(name)
        
    }
    return fn
}
var a = foo()
a()
```
### 关于闭包
- 闭包是一种强大的语法
- 闭包使用不当很容易出现内存泄漏
- 不要为了闭包而闭包

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>闭包陷阱</title>
</head>
<body>
    <!-- <button id="add">add</button> -->
	
	<script>
// 		function foo(){
// 			var el = document.getElementById('add')
// 			el.onclick = function(){
// 				console.log(el.id)
// 			}
// 		}
// 		foo()
		function foo(){
			var el = document.getElementById('add')
			el.onclick = function(){
				console.log(el.id)
			}
			//当DOM节点被删除的时候,咱们js还在对dom进行引用,这时候需要清除js对DOM的引用避免内存泄漏
			el = null;
		}
		foo()
	</script>
</body>
</html>
```
## 避免属性访问方法使用
![image](861BAA3E1E5744C78506F311460EA5EB)


```
function Person(){
	this.name = 'icoder'
	this.age = 18
	this.getAge = function(){
		return this.age
	}
}
const p1 = new Person()
const a = p1.getAge()
// 不使用属性访问方法
function Person(){
	this.name = 'icoder'
	this.age = 18
	
}
const p2 = new Person()
const b = p2.age
```

![image](D8F9DB4F8BC742A6BE7D0B8EA572C50F)
## for循环优化

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>for循环优化</title>
</head>
<body>
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
   
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
   <p class="btn">add</p>
	<script>
		var aBtns = document.getElementsByClassName('btn');
		for(var i = 0 ; i < aBtns.length ; i++){
			console.log(i)
		}
		for(var i = 0, len = aBtns.length;i < len;i++){
			console.log(i)
		}
	</script>
</body>
</html>
```

![image](7CB0E9FD8D3549EBB2C57EF851EE20DE)
## 选择最优的循环方式

```
var arrList = new Array(1,2,3,4,5)
arrList.forEach(function(item){
	console.log(item)
})
for(var i = arrList.length;i;i--){
	console.log(arrList[i])
}
for(var i in arrList){
	console.log(arrList[i])
}
```

![image](C22044E8673D4B00B24ED8602E8FF18F)
![image](35A5B7A625644C888AFC60DD641EE322)

## 文档碎片化节点添加
DOM操作频繁且消耗性能，节点的添加操作必然会有回流和重绘，这样的操作对性能的消耗是比较大的


```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>优化节点操作</title>
</head>
<body>
   
	<script>
		
		for(var i = 0 ; i < 10 ; i++){
			var oP  = document.createElement('p')
			oP.innerHTML = i;
			document.body.appendChild(oP)
		}
		// 创建文档碎片
		const fragEle = document.createDocumentFragment()
		for(var i = 0 ; i < 10 ; i++){
			var oP  = document.createElement('p')
			oP.innerHTML = i;
			fragEle.appendChild(oP)
		}
		document.body.appendChild(fragEle)
	</script>
</body>
</html>
```


## 克隆优化节点操作
当新增节点时，找到类似存在的节点克隆，再去把克隆好的节点直接添加到我们的界面当中，好处是被克隆的节点本身已经具备样式和属性不需要再去添加了

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>克隆优化节点操作</title>
</head>
<body>
   <p id="box1">add</p>
   
	<script>
		for(var i = 0 ; i < 3 ; i++){
			var oP  = document.createElement('p')
			oP.innerHTML = i;
			document.body.appendChild(oP)
		}
		// 克隆优化节点操作
		const oldP = document.getElementById('box1')
		for(var i = 0 ; i < 3 ; i++){
			var newP  = oldP.cloneNode(false)
			newP.innerHTML = i;
			document.body.appendChild(newP)
		}
	</script>
</body>
</html>
```

## 直接采用字面量替换Object操作

```
var a = [1,2,3]
var a2 = new Array()
a2[0] = 1
a2[1] = 2
a2[2] = 3
```
